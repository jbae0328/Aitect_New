@page "/3d"
@inject IJSRuntime JSRuntime

<!-- Revit 스타일 상단 툴박스 -->
<div class="toolbar">
    <div class="toolbar-section">
        <button class="tool-btn active" id="select-tool" onclick="setTool('select')">
            <span class="icon">📍</span>
            <span class="label">Select</span>
        </button>
        <button class="tool-btn" id="point-tool" onclick="setTool('point')">
            <span class="icon">•</span>
            <span class="label">Point</span>
        </button>
        <button class="tool-btn" id="line-tool" onclick="setTool('line')">
            <span class="icon">📏</span>
            <span class="label">Line</span>
        </button>
        <button class="tool-btn" id="rectangle-tool" onclick="setTool('rectangle')">
            <span class="icon">▭</span>
            <span class="label">Rectangle</span>
        </button>
    </div>

    <div class="toolbar-section">
        <button class="tool-btn" onclick="clearAll()">
            <span class="icon">🗑️</span>
            <span class="label">Clear</span>
        </button>
        <button class="tool-btn" onclick="toggleGrid()">
            <span class="icon">⚏</span>
            <span class="label">Grid</span>
        </button>
    </div>

    <div class="toolbar-section coordinates">
        <span id="coordinates">X: 0, Y: 0, Z: 0</span>
    </div>
</div>

<!-- 3D 뷰어 영역 -->
<div id="threejs-container"></div>

<!-- 상태 표시 -->
<div class="status-bar">
    <span id="current-tool">Tool: Select</span>
    <span id="object-count">Objects: 0</span>
</div>

@code {
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("initCADInterface");
        }
    }
}

<script>
    let currentTool = 'select';
    let scene, camera, renderer, raycaster, mouse;
    let isDrawing = false;
    let tempPoints = [];
    let objects = [];
    let gridHelper;
    let gridVisible = true;

    window.initCADInterface = () => {
        // Scene, Camera, Renderer 설정
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0); // 밝은 배경 (Revit 스타일)

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight - 80); // 툴바 공간 제외
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const container = document.getElementById('threejs-container');
        container.appendChild(renderer.domElement);

        // 레이캐스터 및 마우스 설정
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // 그리드 생성
        gridHelper = new THREE.GridHelper(50, 50, 0xcccccc, 0xeeeeee);
        scene.add(gridHelper);

        // 축 표시
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        // 조명 설정
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(20, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // 마우스 이벤트 설정
        setupMouseControls();
        setupDrawingEvents();

        // 애니메이션 루프
        animate();

        console.log("CAD 인터페이스 초기화 완료!");
    };

    function setupMouseControls() {
        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let cameraAngleX = 0.5;
        let cameraAngleY = 0.5;
        let cameraDistance = 25;

        renderer.domElement.addEventListener('mousedown', (event) => {
            if (currentTool === 'select') {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        });

        renderer.domElement.addEventListener('mouseup', (event) => {
            mouseDown = false;
        });

        renderer.domElement.addEventListener('mousemove', (event) => {
            // 마우스 좌표 업데이트
            updateMouseCoordinates(event);

            if (mouseDown && currentTool === 'select') {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                cameraAngleY -= deltaX * 0.01;
                cameraAngleX -= deltaY * 0.01;

                cameraAngleX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleX));

                updateCameraPosition();

                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        });

        renderer.domElement.addEventListener('wheel', (event) => {
            cameraDistance += event.deltaY * 0.02;
            cameraDistance = Math.max(5, Math.min(100, cameraDistance));
            updateCameraPosition();
            event.preventDefault();
        });

        function updateCameraPosition() {
            camera.position.x = Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance;
            camera.position.y = Math.sin(cameraAngleX) * cameraDistance;
            camera.position.z = Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance;
            camera.lookAt(0, 0, 0);
        }

        updateCameraPosition();
    }

    function setupDrawingEvents() {
        renderer.domElement.addEventListener('click', (event) => {
            if (currentTool !== 'select') {
                const intersect = getGroundIntersection(event);
                if (intersect) {
                    handleDrawingClick(intersect.point);
                }
            }
        });
    }

    function getGroundIntersection(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // 가상의 지면 평면과 교차점 계산
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(groundPlane, intersectPoint);

        return { point: intersectPoint };
    }

    function handleDrawingClick(point) {
        switch(currentTool) {
            case 'point':
                createPoint(point);
                break;
            case 'line':
                handleLineDrawing(point);
                break;
            case 'rectangle':
                handleRectangleDrawing(point);
                break;
        }
    }

    function createPoint(position) {
        const geometry = new THREE.SphereGeometry(0.1, 8, 6);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const point = new THREE.Mesh(geometry, material);
        point.position.copy(position);

        scene.add(point);
        objects.push(point);
        updateObjectCount();

        console.log(`Point created at: ${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}`);
    }

    function handleLineDrawing(point) {
        tempPoints.push(point.clone());

        if (tempPoints.length === 2) {
            createLine(tempPoints[0], tempPoints[1]);
            tempPoints = [];
        }
    }

    function createLine(start, end) {
        const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
        const material = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 2 });
        const line = new THREE.Line(geometry, material);

        scene.add(line);
        objects.push(line);
        updateObjectCount();

        console.log(`Line created from (${start.x.toFixed(2)}, ${start.z.toFixed(2)}) to (${end.x.toFixed(2)}, ${end.z.toFixed(2)})`);
    }

    function handleRectangleDrawing(point) {
        tempPoints.push(point.clone());

        if (tempPoints.length === 2) {
            createRectangle(tempPoints[0], tempPoints[1]);
            tempPoints = [];
        }
    }

    function createRectangle(corner1, corner2) {
        const width = Math.abs(corner2.x - corner1.x);
        const depth = Math.abs(corner2.z - corner1.z);
        const centerX = (corner1.x + corner2.x) / 2;
        const centerZ = (corner1.z + corner2.z) / 2;

        const geometry = new THREE.PlaneGeometry(width, depth);
        const edges = new THREE.EdgesGeometry(geometry);
        const material = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
        const rectangle = new THREE.LineSegments(edges, material);

        rectangle.position.set(centerX, 0.01, centerZ);
        rectangle.rotation.x = -Math.PI / 2;

        scene.add(rectangle);
        objects.push(rectangle);
        updateObjectCount();

        console.log(`Rectangle created: ${width.toFixed(2)} x ${depth.toFixed(2)}`);
    }

    function updateMouseCoordinates(event) {
        const intersect = getGroundIntersection(event);
        if (intersect) {
            const point = intersect.point;
            document.getElementById('coordinates').textContent =
                `X: ${point.x.toFixed(2)}, Y: ${point.y.toFixed(2)}, Z: ${point.z.toFixed(2)}`;
        }
    }

    function updateObjectCount() {
        document.getElementById('object-count').textContent = `Objects: ${objects.length}`;
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    // 윈도우 리사이즈 처리
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / (window.innerHeight - 80);
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight - 80);
    });

    // 툴 함수들
    window.setTool = (tool) => {
        currentTool = tool;
        tempPoints = [];

        // 모든 버튼에서 active 클래스 제거
        document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));

        // 선택된 버튼에 active 클래스 추가
        document.getElementById(tool + '-tool').classList.add('active');

        // 상태 업데이트
        document.getElementById('current-tool').textContent = `Tool: ${tool.charAt(0).toUpperCase() + tool.slice(1)}`;

        // 커서 변경
        const container = document.getElementById('threejs-container');
        container.style.cursor = tool === 'select' ? 'grab' : 'crosshair';
    };

    window.clearAll = () => {
        objects.forEach(obj => scene.remove(obj));
        objects = [];
        tempPoints = [];
        updateObjectCount();
        console.log("All objects cleared");
    };

    window.toggleGrid = () => {
        gridVisible = !gridVisible;
        gridHelper.visible = gridVisible;
        console.log(`Grid ${gridVisible ? 'shown' : 'hidden'}`);
    };
</script>

<style>
    body, html {
        margin: 0;
        padding: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f5f5f5;
    }

    .toolbar {
        background: linear-gradient(to bottom, #ffffff, #e8e8e8);
        border-bottom: 1px solid #cccccc;
        height: 60px;
        display: flex;
        align-items: center;
        padding: 0 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
    }

    .toolbar-section {
        display: flex;
        align-items: center;
        margin-right: 30px;
        padding-right: 20px;
        border-right: 1px solid #d0d0d0;
    }

        .toolbar-section:last-child {
            border-right: none;
            margin-left: auto;
        }

    .tool-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 8px 12px;
        margin: 0 2px;
        background: transparent;
        border: 1px solid transparent;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: 60px;
    }

        .tool-btn:hover {
            background: rgba(0, 120, 215, 0.1);
            border-color: rgba(0, 120, 215, 0.3);
        }

        .tool-btn.active {
            background: rgba(0, 120, 215, 0.2);
            border-color: #0078d4;
            box-shadow: inset 0 1px 3px rgba(0, 120, 215, 0.3);
        }

        .tool-btn .icon {
            font-size: 20px;
            margin-bottom: 2px;
        }

        .tool-btn .label {
            font-size: 11px;
            color: #333333;
            font-weight: 500;
        }

    .coordinates {
        background: #f8f8f8;
        padding: 8px 12px;
        border-radius: 4px;
        border: 1px solid #d0d0d0;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        color: #666666;
    }

    #threejs-container {
        margin-top: 60px;
        height: calc(100vh - 100px);
        position: relative;
        cursor: grab;
    }
     
        #threejs-container:active {
            cursor: grabbing;
        }

    .status-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 25px;
        background: #f0f0f0;
        border-top: 1px solid #cccccc;
        display: flex;
        align-items: center;
        padding: 0 20px;
        font-size: 12px;
        color: #666666;
    }

        .status-bar span {
            margin-right: 30px;
        }
</style>